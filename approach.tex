\section{Approach}\label{sec:approach}

\comment{TODO BRAIS: simplify approach section}

\subsection{Syntax Scope and Grounder Simplifications}
\label{sec:syntax-scope}


%
\begin{itemize}
  \item
  We consider disyunctive ground logic programs with choice rules under the answer set semantics.
  %
  \item This is to avoid the simplifications that grounders do, which can be hard to track back to the original program.
  \item One of the reason for this simplifications is to have a simple normal form that can be interpreted by the solver.
  %
  \item This normal form allows disjunction or choices in the head, and either a sum aggregate with a lower bound or a conjunction of literals in the body \citep{kamrom23a}.
  \item To transform all available constructs in clingo into this normal form, the grounder introduces auxiliary atoms.
  \item This means that we will get auxiliary atoms when using
  $\#sum$ or $\#count$ aggregates, as well as
  anonymous variables,
  conditional literals,
  and choice rules with bounds or conditional literals within them.
  \item Furthermore, we do not consider sum aggregates, as this would require a more complex graph with weighted edges, and a special type of node to sum them up.
  \item We don't consider double negation.
  %
\end{itemize}
%

\subsection{Labeled Logic Programs}
\label{sec:labeled-logic-programs}

%
\begin{itemize}
  \item We use labelled logic programs to use the label as identifier in the program graph.
  \item We also only use the labels in the examples to avoid writing the full rule.
\end{itemize}
%

%
\paragraph{Labelled Ground Disjunctive programs}
A \emph{(labelled) rule} is an implication either of the form
\begin{eqnarray}
  \ell : p_1 \vee \dots \vee p_m \leftarrow q_1 \wedge \dots \wedge q_n \wedge \neg s_1 \wedge \dots \wedge \neg s_j \label{f:disjunctive-rule}
\end{eqnarray}
%
or of the form
%
\begin{eqnarray}
  \ell : \{p_1;\ \dots;\ p_m\} \leftarrow q_1 \wedge \dots \wedge q_n \wedge \neg s_1 \wedge \dots \wedge \neg s_j \label{f:choice-rule}
\end{eqnarray}
where $m, n, j \in \mathbb{N}_0$ (i.e., non-negative integers),
%
For any of the forms \eqref{f:disjunctive-rule} and \eqref{f:choice-rule}, we use $\Bd{r}$ and $\Hd{r}$ to refer to the \emph{antecedent} and the \emph{consequent} of the implication respectively.
%
We denote the set of atoms in the head of $r$ as
$\HH{r} \eqdef \{p_1, \dots, p_m\}$ in the case of rules of the form \eqref{f:disjunctive-rule}
and as $\HH{r} \eqdef \{a_1, \dots, a_k\}$ in the case of rules of the form \eqref{f:choice-rule}.
%
The set of atoms in the positive body are represented as
$\BB{r} \eqdef \{q_1,\dots,q_n\}$
and
the set of atoms in the negative body are represented as
$\BBn{r} \eqdef \{s_1,\dots,s_n\}$.
%
A \emph{(labelled) logic program} is a set of labelled rules.
%
Note that given any logic program $P$, we can get a labelled logic program by simply labelling each rule with an incremental identifier.
%
Given a rule $r$ like \eqref{f:disjunctive-rule} or \eqref{f:choice-rule}, we denote its label as $\Lb{r}\eqdef \ell$,
%
and so, we denote the rule $r$ corresponding to a label $\ell$ as $\InvLb{\ell}$.
%
We denote $\Lbs{P} \eqdef \{ \Lb{r} \mid r \in P \}$ as the set of all labels of the rules in a labelled program $P$.
%
$\isdisj{P} \subseteq P$ is the set of rules whose head is a (non-empty) disjunction,
whereas
$\iscons{P} \subseteq P$ is the set of rules whose head is an empty disjunction, that is, constraint rules.
Therefore, rules in $\isdisj{P} \cup \iscons{P}$ are rules of the form \eqref{f:disjunctive-rule} and $\isdisj{P} \cap \iscons{P} = \emptyset$.
$\ischoice{P} \subseteq P$ is the set of ulres whose head is a choice, that is, rules of the form \eqref{f:choice-rule}.
Finally, $\atoms{P}$ is the set of all the atoms occuring in $P$.
%
As usual, we will denote the set of answer sets of labelled program $P$ as $AS(P)$.
%


\subsection{Program Graph}
\label{sec:program-graph}

%
\begin{definition}[Program Graph]
%
Given a labelled logic program $P$, its corresponding \emph{program graph} is
defined as
$\pg{P} = \pgfull$
where
%
$\Vc$, $\Vd$ and $\Va$ are nodes in the graph following the definitions below:
\begin{itemize}
    \item $\Vd = \{ \Lb{r} \mid r \in P \cap (\isdisj{P} \cup \iscons{P}) \}$ is the set of rules's labels, whose head is a dijunction;
    \item $\Vc = \{ \Lb{r} \mid r \in P \cap \ischoice{P} \}$ is the set of rules's labels, whose head is a choice;
    \item $\Va = \{ a      \mid a \in \atoms{P} \}$ is the set atoms which occur within any head of any rule in $P$.
\end{itemize}

and $\Epos$ and $\Eneg$ are the sets of edges of the graph such that:
\begin{itemize}
  \item $\forall r \in P, \forall a \in \BB{r}  \rightarrow (a,\Lb{r})  \in \Epos$
  \item $\forall r \in P, \forall a \in \BBn{r} \rightarrow (a, \Lb{r}) \in \Eneg$
  \item $\forall r \in P, \forall h \in \HH{r}  \rightarrow (\Lb{r}, h) \in \Epos$
\end{itemize}
%
\end{definition}
%



\paragraph{Discussion points}
\begin{itemize}
  \item
  A program graph can be seen as a directed graph
  \ensuremath{\langle \Vc \cup \Vd \cup \Va, \Epos \cup \Eneg \rangle}
  that syntactically represents a logic program,
  capturing all details specified by the ASP developer.
  It serves as the foundational structure for generating explanations.
\end{itemize}

%
\begin{example}[Program Graph]\label{ex:example1}
  This is an extension of the introductory example from~\cite{cabfan17a}.
  A drug $d$ in James Bond’s drink causes his paralysis $p$
  provided that he was not given an antidote $a$ that day.
  We know that Bond’s enemy, Dr. No, poured the drug. He gets the antidote if he is not on holiday $h$.
  Unlike in the original example, we add $w$ to indicate a working day,
  and a choice to decide if James is on holiday or working,
  where the constraints in rules 2 and 3 ensuring exactly one of them is true.
  %
  Note that adding the choice with bounds would have introduced auxiliary atoms as explained before in Section~\ref{sec:syntax-scope}.
  %%
  \lstinputlisting[caption={Modified James Bond Example. Program $P1$ (\texttt{encoding.lp})}, language=clingos, label={lst:example1}]{encodings/example1.lp}
  %%
  $P1$ has two models, namely $\m_1 = \{h, d, p\}$ and $\m_2 = \{w, d, a\}$,
  where James is not poisoned in $\m_2$ since he is working and gets the antidote,
  and he is poisoned in $\m_1$ since he is on holiday and does not get the antidote.
  %
  Figure~\ref{fig:program-graph} shows the program graph corresponding to program $P1$.
  %
  \begin{figure}
    \centering
    % \includegraphics[width=0.75\textwidth]{resources/program-graph.png}
    % \includesvg[width=\textwidth]{resources/pg.svg}   %%% fails to scale text: asplain's or latex's problem?
    \includegraphics[scale=0.05]{resources/pg.png}
    \label{fig:program-graph}
    \caption{Program graph $G_{P_{1}}$ corresponding to program in Listing~\ref{lst:example1}. }
  \end{figure}
  %
  Circle-nodes in graph $G_{P_{1}}$ represent atoms appearing in $P1$, that is, the set $\Va = \{d,a,h,w,p\}$.
  %
  Rectangle-nodes in graph $G_{P_{1}}$ represent the body of some rule in $P1$, in particular, sets $\Vc = \{r1\}$
  and $\Vd = \{r2,r3,r4,r5,r6\}$ correspond to the set of rules in $P1$ whose head is a choice, respectively a disjunction.
  %
  Edges in $E^{+}$ are represented by solid arrows, while edges in $E^{-}$ are represented by dashed arrows.
  Edges from atoms to rules correspond to positive and negative literals.

  % For any atom (circle-node) $a \in \Vc$ for which it exists some rule $r$
  % for which $a \in \HH(r)$, it must exist a solid edge $(r,a) \in E^{+}$.
  % %
  % For any atom (or circle-node) $a \in \Vc$ for which it exists some rule $r$ for which $a \in \BB{r}$ (or respectively $a \in \BBn{r}$), it must exist a solid (respectively dashed) edge $(a,r) \in E^{+}$ (or respectively $(a,r) \in E^{-}$).
  % %

  %
  Note how, as expected, facts are depicted in the graphs as square nodes without any incoming edge, while constraints are depicted as square nodes without any outgoing edge.
  %
\end{example}


\begin{proposition}
  If two programs have the same program graph, they are strongly equivalent.
\end{proposition}
%

\begin{proposition}
  Given two labelled disyunctive, ground programs $P1$ and $P2$ and their respective program graphs $\pg{P1}$ and $\pg{P2}$, then
  \[ \pg{P1} = \pg{P2} \rightarrow P1 = P2 \]
\end{proposition}


%%%%%%%%%%%%%%%%%%% EXPLAINING MODELS

\subsection{Explaining a model: Model Subgraph}
\label{sec:model-subgraph}

\begin{definition}[Model Subgraph from Model]
  Given a program graph $\pg{P} = \pgfull$,
  and an answer set $\m \subseteq \Va$ of $P$,
  a \emph{model subgraph} is a pair $\mgpi{P}{\m} = \langle V, E \rangle$ such that
  \begin{itemize}
    % take all the atoms in the model as nodes and all the supported rules as nodes as welll
    \item $V = \m \cup \{ \Lb{r} \mid r \in P \land \m \models \Bd{r} \}$
    % any join all the included nodes using positive edges only
    \item $E = \{ (v_1, v_2) \mid (v_1, v_2 \in V)\ \land\ (v_1, v_2) \in \Epos  \}$
  \end{itemize}
\end{definition}

%
\begin{proposition}
  Given a program $P$ and a model $\m$ of $P$,
  the \emph{model subgraph} $MG_P^\m$ is a subgraph of the \emph{program graph} $\pg{P}$.
\end{proposition}
%
\begin{figure}
  \centering
  \includegraphics[scale=0.05]{resources/foil.png}
  \caption{Visualization of model subgraph $\mgpi{P1}{\m_1}$.}
  \label{fig:model-subgraph}
\end{figure}


\paragraph{Discussion Points}
\begin{itemize}
  \item Intuition: we use a given model to extract a subgraph from the program graph,
  that highlights (1) supportiveness of atoms in the model; (2) supportiveness of rules; and (3) the truthness of the positive literals in the body.
  \item Negative edges are not included in the model subgraph
  since their origin atom would not be in the model and thus not part of the model subgraph.
  \item To include the information of negative literals in an explanation, we can compare the model subgraph with the program graph.
  This comparison is relevant as it gives us the information to provide causal explanations which include negative implications.
  \item
  A visualization example for $\mgpi{P1}{\m_1}$ with is shown in Figure~\ref{fig:model-subgraph}.
  We show the program graph $\pg{P}$ in the background, and highlight the model subgraph $\mgpi{P}{\m}$ for the given model $\m$ on top of it.
  As such, atoms are colored if they appear in the model and
  rules are colored if their body is supported by the model.
  Edges for positive literals are highlighted if they are satisfied by the model.
  While edges from rules to atoms are highlighted if the atom is in the model, indicating that it could be derivated by that supported rule.
  \item Notice, does not select any particular derivation when alternative causes emerge.
  (that is, is not causal) (is not equivalent to \cite{cabmun24a} but could be equivalent to \cite{altrsoba23a})
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%% ABDUCTION

\subsection{Abduction for Explanation}
\label{sec:abductive-explanations}

%       Extended version
% \paragraph{Context and Motivation}
% \begin{itemize}
%   \item Contrastivness is one of the main properties of human explanations~\cite{miller19}.
%   %
%   \item First, explanation-asking question (or queries) from humans are often contrastive, which means that they ask for some event that is not true in a world or scenario that is taken as reference.
%   %
%   \item To put an example, a typical human question/query would be \textit{Why isn't James posioned?}, implying a the existence of a scenario where James is not poisoned and that the asking human is taking as a reference.
%   %
%   \item In the real world, this reference world is normally a particular interpretation of the asking human about some events that she perceived.
%   %
%   \item A valid human contrastive explanation to that query will have to contrast the reference scenario with an alternative one where the question previously made is positively answered.
%   %
%   \item This alternative or hypothetical world is reffered in literature as \emph{foil}, whereas the reference world is reffered as \emph{fact}.
%   %
% \end{itemize}

\paragraph{Context and Motivation}
\begin{itemize}
  %
  \item Humans usually ask for explanations when they expect some event, but are exposed to a different outcome/situation instead.
  %
  \item People ask “why not” questions relative to a reference and hypothetical/alternative scenarios.
  %
  \item Example: \textit{Why isn’t James poisoned?} — the asker \emph{assumes} or \emph{expects} a hypothetical world where James is poisoned.
  %
  \item This hypothetical world is called \emph{foil}, whereas the \emph{reference world} is the asker’s interpretation of observed events where James is not poisoned.
  %
  \item In ASP context, this happens, for instance, when the users expects something that does not happen in the shown solution.
  %
  \item Examples:
  \begin{itemize}
    \item User expected $a$ to be in the answer, but it's not.
    \item User expected $a$ not to be in the answer, but it is.
    \item User expected $a$ to be in the answer, but there is no answer (UNSAT).
  \end{itemize}
  %
  \item The way human answer this type of questions, accoring to social sciences literature~\cite{miller19}, is by finding and presenting foils which match the expectations.
  %
  \item Our approach mimics this process, by finding alternative answer sets (and even alternative programs if needed) which satisfy the user unsatisfied expectations.
  %

\end{itemize}
%

\paragraph{Assumptions}
\begin{itemize}
  %
  \item We start from a \emph{reference} program $\pr$,
  %
  \item and a Query $Q$ which represents the user's unmet expectations about the program and/or any of its answer sets.
  %
  \item From there, we add and remove rules from $\pr$ in a controlled way so that we find a new program $\pf$, such that
        an answer set $\m_f$ of $\pf$ such that $\m_f \models Q$.
  %
  \item We refer to the new program $\pf$ as the \emph{foil program}, we use the term \emph{abduction} to refer to the process of finding it and finally, we refer to $\m_f$ as the \emph{foil model}.
  %
\end{itemize}
%

%
\begin{definition}[Valid Foil]\label{def:valid-foil}
  Given
  \begin{itemize}
    %
    \item a set of literals $Q$ refered as \emph{query},
    %
    \item a \emph{reference program} $\pr$,
    %
    \item a set of \emph{removable} labelled rules $\removable \subseteq \pr$
    %
    \item and
    %
    \item a set of \emph{addable} labelled rules $\addable$.
    %
  \end{itemize}
  %
  we say the pair $(\pf, \m_f)$
  is a \emph{valid foil for $\pr$ with respect to some $\addable$, $\removable$ and $Q$} iff:
  \begin{itemize}
    \item $ \pr \setminus \removable \subseteq \pf \subseteq (\pr \cup \addable)$
    \item $\m_f \in AS(\pf)\ \land\ \m_f \models Q$
  \end{itemize}
  Additionally, we denote $\foils(\pr, \addable, \removable, Q)$ as the set of \emph{all valid foils for $\pr$ with respect to $\addable$, $\removable$, and $Q$}.
\end{definition}
%
\paragraph{Discussion on Valid Foil (Def. \ref{def:valid-foil})}
\begin{itemize}
  \item Intuitively, for obtaining a valid foil you can take $\pr$, and you may add/remove anything from $\addable$ and $\removable$ to obtain a new foil program $\pf$. For any model $\m_f$ of $\pf$ that satisfies the query $Q$, you can form a valid foil.
  %
  \item Also, note that $\pf$ may be equal to $\pr$ meaning that we did not add or remove anything from $\pr$ and we still find a $\m_f$ model that satisfies the query. That is, there was another model of $\pr$ that satisfy the query and can be used to explain \emph{why not} $Q$.
  %
  \item In the case that the set $\foils(\pr, \addable, \removable, Q) = \emptyset$, this means that there is no way to satisfy the query even if removing or adding any combination from $\removable$ or $\addable$.
  %
  \item Of course, note that there is no restrictions over both the $\removable$ or $\addable$ sets, which means that one could put potentially anything there. Therefore, some $\addable$ or $\removable$ sets can be weird.
  \begin{itemize}
    \item For instance, adding rules which do not interact at all with the rest of rules in $\pr$ (they do not share language).
  \end{itemize}
  %
  % \item Regarding contrastive explanations, from a \emph{reference program} and a query $Q$, the idea is to find a \emph{foil valid subgraph} $MG_{\pf}^{\m_f}$ with with respect to $Q$, that will be later used to compute a contrast graph $CG_{\pr, \pf}^{\m_r, \m_f}$.
  %
  \item {\color{blue} This definition does not impose the existence of a \emph{reference model} $\m_r \models \pr$}
  This allows finding foils for unsatisfiable reference programs.
  This is the case when $AS(\pr) = \emptyset$ and $Q = \emptyset$, which intuitively means that we are simply recovering satisfiability.
  Otherwise, if $Q \neq \emptyset$, we are recovering satisfiability and forcing something to be true in the process.
  \item {\color{blue} This definition does not impose that $\m_r \nvDash Q$.}
  Therefore, the reference and foil models may collide $\m_r = \m_f$,
  which means that we are in fact doing no contrast.
  In other words, $\m_r$ already satisfy the query.
  Analyzing the the model subgraph $\mgpi{\pr}{\m_r}$ in comparison to $\pg{P}$,
  can then provide a causal explanation for \emph{why} $Q$.
  %
  \item The sets $\removable$ and $\addable$ is what we informally call them \emph{abducibles}, that is, rules that we can add or remove to the original program in order to satisfy the query.
  %
  \item The most natural example of the abducibles is \emph{user input}, but any other notion can be abducible if it makes sense for the application.
  \item For instance, one could set the removable rules as all constraints, $\removable=\{r \mid r \in \iscons{r}\}$, for debugging purposes to find out why the program is unsatisfiable.
  %$
  \item The set $\removable$ (\emph{removables}) is restricted to be a subset of $\pr$, while the set $\addable$ (\emph{addables}) is free, since we want to give full flexibility.
  %
  \item The idea is that they are defined for each use-case: the scope will be given as part of the domain, as user preference, as a programmer criteria, etc.
  %
  % \item There exist two important sets that are not needed in the definition, those are:
  % \comment{We add this sets here but latter on when defining a cost there is no reference to them, are they really relevant then?, I think we can just remove this part here}
  % \begin{itemize}
  %   %
  %   \item $\added = \pf \setminus \pr \subseteq \addable$, that is, the set of rules that were \emph{added}.
  %   %
  %   \item $\removed = \pr \setminus \pf \subseteq \removable$, that is, the set of rules that were \emph{removed}.
  %   %
  %   \item $\added$ and $\removed$ will play an important role when designing and implementing good explanation preferences.
  % \end{itemize}

\end{itemize}
%

\begin{example}[Abduction]\label{ex:example2}
  Consider $P2$ as the extension of $P1$ with the following rule which ensures that James is on holiday.
  \begin{lstlisting}[language=clingos]
    r7: :- not h.
  \end{lstlisting}

  % %
  % Recall $P$\ref{lst:example1} from Example~\ref{ex:example1}, and consider $P$\ref{lst:example2}, which only adds rule $7$, forcing to be a holiday.
  % %
  % \lstinputlisting[caption={Program $P$\ref{lst:example2}}, label={lst:example2}]{encodings/example2.lp}
  % %
  Now, imagine that a user is shown $P2$'s unique model $\m_2$,
  and let's say that they are surprised that James is poisoned and want to know why.
  To answer the question we can preform abduction by calculating $\foils(P2, \emptyset, \{r6, r7\}, \{ \neg p \})$,
  % where $Q = \{ \neg p \}$ which is the expected outcome from the user's point of view,
  % $\removable = $ and $\addable = \emptyset$.
  This yields four valid foils that satisfy the query, namely,
  $(P2\setminus \{r7\}, \{w, d, a\})$,
  $(P2\setminus \{r6\}, \{h\})$,
  $(P2\setminus \{r6, r7\}, \{h\})$ and
  $(P2\setminus \{r6, r7\}, \{w, a\})$.
  These foils can be visualized using their corresponding model subgraphs as shown in Figure~\ref{fig:foils}.
  %
  We use the color green to highlight foil models to latter distinguish them from the reference model which is always shown in purple color.

\end{example}
%
\begin{figure}
  \centering
  \begin{tabular}{cc}
    \includegraphics[scale=0.05]{resources/f1.png} &
    \includegraphics[scale=0.05]{resources/f2.png} \\
    \includegraphics[scale=0.05]{resources/f3.png} &
    \includegraphics[scale=0.05]{resources/f4.png} \\
  \end{tabular}
  \caption{Visualizations of the four valid foils for $P2$ in Example~\ref{ex:example2}.
  Top figures remove rule $7$ (left) and rule $6$ (right).
  Bottom figures remove both rules, getting the same foil program but different models.}
  \label{fig:foils}
\end{figure}


% \subsubsection{Abduction for unsat instances}



% \begin{example}[Abduction for UNSAT]\label{ex:example3}
%   %
%   Let us consider the \emph{unsatisfiable} program $P$\ref{lst:example3}
%   %%
%   \lstinputlisting[caption={Program $P$\ref{lst:example3}}, label={lst:example3}]{encodings/example3.lp}
%   %%
%   Now consider that we want to find reasons why this program is unsatisfiable.
%   %
%   We might find different explanations depending how do we frame it as the problem of finding a valid foil.
%   %
%   First we will consider $P$\ref{lst:example3}$ = \pr$
%   and
%   $Q = \emptyset$ since we are only interested in recovering satisfiability.
%   Also, we will always consider $\addable = \emptyset$ for this example.
%   %

%   %
%   If we say that $\removable = \{ 4 \}$, then there is only one \emph{valid foil subgraph} depicted in Figure~\ref{fig:example3-1}.
%   %
%   If we however consider $\removable = \{ 2, 3 \}$, then there are three possible \emph{valid foils} depicted in Figure~\ref{fig:example3-2}.
% \end{example}
%
% \begin{figure}
%   \centering
%   \includegraphics[width=0.3\textwidth]{resources/example3-1.png}
%   \caption{Valid foil for $P$\ref{lst:example3} with respect to $Q = \emptyset$, when $\removable = \{ 4 \}$. Only (constraint) rule 4 was removed.}
%   \label{fig:example3-1}
% \end{figure}
%
% \begin{figure}
%   \centering
%   \begin{minipage}[b]{0.32\textwidth}
%     \centering
%     \includegraphics[width=\textwidth]{resources/example3-2-1.png}
%     % \label{fig:example3-2-1}
%   \end{minipage}
%   \hfill
%   \begin{minipage}[b]{0.32\textwidth}
%     \centering
%     \includegraphics[width=\textwidth]{resources/example3-2-2.png}
%     % \label{fig:example3-2-2}
%   \end{minipage}
%   \hfill
%   \begin{minipage}[b]{0.32\textwidth}
%     \centering
%     \includegraphics[width=\textwidth]{resources/example3-2-3.png}
%     % \label{fig:example3-2-3}
%   \end{minipage}
%   \caption{Valid foils for $P$\ref{lst:example3} with respect to $Q = \emptyset$,
%   when $\removable = \{ 2, 3 \}$.
%   Foils left and middle correspond to remove only rules $2$ and $3$ respectively, whereas left foil correspond to remove both.}
%   \label{fig:example3-2}
% \end{figure}

\subsubsection{Selecting the best Foil}
\label{sec:best-foil}

\paragraph{Motivation and Context}
\begin{itemize}
  \item Among all possible foils, humans tend to select the most suitable ones according to different criteria.
  %
  \item Since our framework allows full flexibility in generating possible foils, we also need a good way to identify the most appropriate ones.
  %
  \item
  In the social sciences, several notions of preference or selection criteria have been discussed, ranging from the degree of difference between the fact and foil worlds (the smaller, the better), to temporal or probabilistic considerations.
  This is well studied in~\cite{miller19}.
  %
  \item Other contrastive approaches, such as \cite{eigeoe23a}, only allow to minimize the difference between both worlds or restrict attention to minimal ones.
  %
  \item We pursue a more general perspective by introducing an abstract \emph{cost function} that assigns each foil a numerical value, thus establishing an order relation among foils.
  %
  \item Each concrete implementation of this function represents a criterion that can be used to select among foils by minimization.
  %
  \item Examples of possible criteria include:
  \begin{itemize}
    \item the number of rules that were added or removed and the type of such rules (e.g., constraints vs. standard rules),
    % \item the differences between what holds true or false in the two models,  % this is for contrastive
    \item the difference between the two models in terms of atoms that are true in one but not the other,
    \item domain-specific distances, such as the cost of modifying a plan in planning scenarios.
  \end{itemize}
  %
  \item The identification, definition, and implementation of such criteria deserve dedicated effort, as they directly affect the relevance and usefulness of the explanations from a user’s perspective.
  %
  \item In the following, we define the abstraction formally and propose several implementations that, in our view, cover common use cases—while remaining flexible for systems to define their own.
\end{itemize}


\begin{definition}[Foil cost function]\label{def:foil-cost}
  Given
  \begin{itemize}
    \item a query $Q$,
    %
    \item a reference program $\pr$,
    %
    \item a set of removable labelled rules $\removable \subseteq \pr$,
    %
    \item and a set of addable labelled rules $\addable$,
  \end{itemize}
  %
  a \emph{foil cost function} is a function
  %
  \[
    \foilcost_{\pr,\addable,\removable,Q} :
    \foils(\pr, \addable, \removable, Q) \rightarrow \mathbb{N}.
  \]
  that assigns each foil $(\pf, \m_f)$ a numerical value representing a cost with respect to the reference program.
\end{definition}

\begin{definition}[Best foils]\label{def:best-foils}
  Given
  \begin{itemize}
    \item a query $Q$,
    %
    \item a reference program $\pr$,
    %
    \item a set of removable labelled rules $\removable \subseteq \pr$,
    %
    \item and a set of addable labelled rules $\addable$,
    %
    \item and a foil cost function $\foilcost$,
  \end{itemize}
  %
  the set of \emph{best foils} is defined as
  %
  \[
  \bestfoils(\pr, \addable, \removable, Q, \foilcost)
    = \operatorname*{arg\,min}_{(\pf, \m_f) \in \foils(\pr, \addable, \removable, Q)}
      \foilcost_{\pr,\addable,\removable,Q}(\pf, \m_f).
  \]
\end{definition}

\paragraph{Discussion}
\begin{itemize}
  %
  \item The idea to find good explanations for users is that we first design and implement a good preference for selecting explanations, that is, a good cost function.
  %
  \item Then, $\bestfoils$ contains all valid foils that achieve the minimal value of the selected cost function.
  %
  \item These represent the preferred foils according to the specified preference.
\end{itemize}


\begin{example}[Program-difference cost function]\label{ex:program-difference-cost-function}
   Given
  \begin{itemize}
    \item a query $Q$,
    %
    \item a reference program $\pr$,
    %
    \item a set of removable labelled rules $\removable \subseteq \pr$,
    %
    \item and a set of addable labelled rules $\addable$,
  \end{itemize}
  %
  we define the particular foil cost function \emph{program difference} $\varphi$,
  % \[
  %   \pdiff_{\pr,\addable,\removable,Q} :
  %   \foils(\pr,\addable,\removable,Q) \rightarrow^{} \mathbb{N}
  % \]
  defined as follows:
  \[
    \pdiff(\pf, \m_f)
    = |\,\pr \,\triangle\, \pf\,|,
  \]
  where $\triangle$ denotes the \emph{symmetric difference} between the sets of rules
  in $\pr$ and $\pf$.
  %
\end{example}

\paragraph{Discussion on Program Difference Function}
\begin{itemize}
  \item This cost function reflects how many rules differ between the reference and the foil program i.e. how many rules were added/removed.
  %
  \item Minimizing $\pdiff$ therefore selects foils that are syntactically closest to the reference program.
  %
  \item We belive this is one of the typical preferences that we can use.
  %
  % \item Also, note that $\pdiff$ previous definition is equivalent to
  % \[
  % \pdiff(\pf, \m_f)
  %   = |\removable'| + |\addable'| = |\pr \setminus \pf| + |\pf \setminus \pr|
  % \]
\end{itemize}

\begin{example}[Selecting minimal foils using the program-difference cost]\label{ex:best-foils}
  By applying
  $\pdiff$ to the foils obtained in  Example~\ref{ex:example2}
  we assign each foil a value proportional to the number of rules that differ from the reference program.
  %
  In this case, the first two foils that remove a single rule receive a cost of $1$, while the foils removing both rules receives a cost of $2$.
  %
  Therefore,
  \[
  \bestfoils(P2, \emptyset, \{r6, r7\}, \{ \neg p \}, \pdiff)
    = \{(\pf, \m_f) \in \foils(P2, \emptyset, \{r6, r7\}, \{ \neg p \})
        \mid |\,P2 \triangle \pf\,| = 1\}.
  \]
  %
  Minimizing $\pdiff$ thus selects the two top foils from Figure~\ref{fig:foils},
  which are the foils that made the least changes to the original program.
\end{example}


%%%%%%%%%%%%%%%%%% CONTRASTIVE EXPLANATIONS

\subsection{Contrastive Explanations}
\label{sec:contrastive-explanations}

\paragraph{Context and Motivation}
\begin{itemize}
  %
  \item On top of using abduction to figure out valid foils, humans tend to leverage from the differences between the \emph{reference} and the \emph{foil} when explaining something.
  %
  \item A contrastive explanation compares this \emph{reference world} with an \emph{foil world} where the outcome differs.
  %
  \item With this comparison we will be able to use causal relations \emph{hidden} in constraints by using \emph{existential satisfaction}, defined below.
  %
\end{itemize}

\begin{definition}[Existential Satisfaction]
  Given two sets of atoms $\m_1$ and $\m_2$ we define the \emph{existential satisfaction} relation, written
  \[ \m_1,\m_2 \models · \]
  that holds according to the following cases:
  \begin{itemize}
    \item for a literal $l$ of the form $a$ or $\neg a$
    \begin{itemize}
      \item $\m_1,\m_2 \models a \iff a \in \m_1 \vee a \in \m_2$
      \item $\m_1,\m_2 \models \neg a \iff a \notin \m_1 \vee a \notin \m_2$
    \end{itemize}
    \item for sets of literals $B$
    \begin{itemize}
      \item $\m_1,\m_2 \models $B$ \iff \m_1,\m_2 \models l$ for every $l \in B$.
    \end{itemize}
    \item for a rule $r$ of the forms \eqref{f:disjunctive-rule} or \eqref{f:choice-rule}
    \begin{itemize}
      \item $\m_1,\m_2 \models r \iff \m_1,\m_2 \models \Bd{r}$
    \end{itemize}
  \end{itemize}
\end{definition}

\paragraph{Discussion on Existential Satisfaction}
\begin{itemize}
  \item Will be used to identify the conflict constraints among the masks used for a contrast.
  \item Is a relaxed notion of satisfaction that can be read as \emph{this constraint would have been fired}.
  \item This concept can be extended to other rules that are not integrity constraints,
  however, this is more complex as we would need to consider their head with different semantics.
  This remains future work.
  For now, we focus on constraints only as this is the information that we want to laverage from common programming practices.
\end{itemize}

\begin{definition}[Contrastive Subgraph]
  Given
  \begin{itemize}
    \item a set of literals $Q$ refered as \emph{query},
    %
    \item a reference program-model pair $\langle \pr, \m_r \rangle$ such that $\m_r \models \pr$, $\m_r \not\models Q$, and its correspondant subgraph $\mgpi{\pr}{\m_r} = \langle V_r, E_r \rangle$,
    %
    \item sets $\addable$ and $\removable$, of \emph{addable} (respectively \emph{removable}) rules, a \emph{valid foil program-model pair} $(\pf, \m_f) \in \foils(\pr, \addable, \removable, Q)$, and its correspondant model subgraph $\mgpi{\pf}{\m_f} = \langle V_f, E_f \rangle$.
    %
    \item a program graph $\pg{\pr \cup \pf} = \pgfull$
  \end{itemize}
  then
  %
  a \emph{contrastive subgraph} is the tuple
  \[
  \cg{\pr}{\pf}{\m_r}{\m_f} =
  \langle
    \Vcon, % 1. reference nodes, foil nodes, constraint nodes (or conflict nodes?)
    \langle \Eposcon, \Enegcon \rangle  % fact/foil positive edges, negative edges
  \rangle
  \]
  %
  where
  \begin{itemize}
    \item  $\Vcon = V_r \cup V_f \cup  \{ \Lb{r} \mid (r \in (\pr \cup \pf) \cap \iscons{r}) \land (\m_r, \m_f \models \Bd{r}) \}$
    \item $\Eposcon = \{(v1, v2) \mid (v1, v2) \in \Epos \land v1,v2 \in \Vcon\}$
    \item $\Enegcon = \{(v1, v2) \mid (v1, v2) \in \Eneg \land v1,v2 \in \Vcon\}$
    \item $\Enegcon = \{ (a, \ell) \mid (a, \ell) \in \Eneg \land [ (\m_r \models a) \oplus (\m_f \models a)]\}$
  \end{itemize}
\end{definition}
%
\begin{proposition}
  Given a \emph{contrastive graph} $\cg{\pr}{\pf}{\m_r}{\m_f}$,
  \begin{itemize}
    \item $\mgpi{\pr}{\m_r}$ is a subgraph of $\cg{\pr}{\pf}{\m_r}{\m_f}$
    \item $\mgpi{\pf}{\m_f}$ is a subgraph of $\cg{\pr}{\pf}{\m_r}{\m_f}$
    \item $\cg{\pr}{\pf}{\m_r}{\m_f}$ is a subgraph of $\pg{\pr \cup \pf}$.
  \end{itemize}
\end{proposition}
%

\paragraph{Discussion Points}
\begin{itemize}
  %
  \item We can build contrastive explanations or contrastive graphs only when we have a {\color{blue} satisfiable reference program}.
  %
  \item On top of the model subgraphs, the contrastive subgraphs additionally highlight: (1) \emph{constraint conflicts} and (2) \emph{negative edges}.
  %
  \item {\color{blue} Important: asplain allows the reference to fulfill the query. In those case, the reference and the foil are the same and we use that to capture positive justifications of queries as well as contrastive explanations. See below a discussion on that.}
  %
\end{itemize}

\paragraph{Discussion on Types of Contrasts}
\begin{itemize}
  \item We may separate contrasts in types depending on the (dis)equalities among the model subgraphs used $\mgpi{\pr}{\m_r} = \langle V_r, E_r \rangle$ and $\mgpi{\pf}{\m_f} = \langle V_f, E_f \rangle$.
  \item We propose the following types
  \begin{itemize}
    \item when $\pr = \pf \land \m_r = \m_f$, so that $\m_r \models Q$ then we call it \emph{positive justification}.
    \item when $\pr = \pf \land \m_r \neq \m_f$ then we call it \emph{alternative contrastive explanation}.
    \item when $\pr \neq \pf$ then we call it \emph{hypothetical contrastive explanation}.
  \end{itemize}
  \item Note that, when we start from an unsat program (as in Section~\ref{sec:abductive-explanations}) we can only compute hypothetical contrastive explanations as we need a foil program $\pf$ for having any $\m_f \models Q$.
\end{itemize}

\paragraph{Finding Contrastive Explanation for Queries}
\begin{itemize}
  \item We first start from the assumption that there exists some referece model $\m_r$ of some reference program $\pr$ that has been shown to (or selected by) the user.
  %
  \item Then the user wonders why some query $Q$ is not true in the reference.
  %
  \item We use abduction to find a $\mgpi{\pf}{\m_f} \in \foils(\pr, \addable, \removable, Q)$, for some $\removable$ and $\addable$.
  %
  \item Sets $\removable$ and $\addable$ can vary depending on the particular application.
  %
  \item Finally, we compute $\cg{\pr}{\pf}{\m_r}{\m_f}$
\end{itemize}


\begin{figure}
  \centering
  \begin{tabular}{cc}
    \includegraphics[scale=0.05]{resources/c1.png} &
    \includegraphics[scale=0.05]{resources/c2.png} \\
  \end{tabular}
  \caption{Visualizations of the two contrastive graphs for the best foils of $P2$ in Example~\ref{ex:example2}.}
  \label{fig:contrastive}
\end{figure}

\begin{example}[Contrastive Explanations for a query]\label{ex:example4}
  Following our examples, let be $(P2_f, \m 1_f)$ be a foil in
  $\bestfoils(P2, \emptyset, \{r6, r7\}, \{ \neg p \}, \pdiff)$
  %
  we can build a contrastive graph $\cg{P2}{P2_f}{\m 1}{\m 1_f}$.
  The visualization of these graphs is shown in Figure~\ref{fig:contrastive}.
  %
  The first contrastive graph (left) corresponds to the foil that removes rule $r7$,
  and can be read as if James had not been forced to be on holiday,
  he would have been working, otherwise it would have violated the constraint of being either on holiday or working.
  If he had been working, he would have taken the antidote and therefore not been poisoned.
  %
  The second contrastive graph (right) corresponds to the foil that removes rule $r6$,
  and can be read as if James had not drunk the poison,
  he would not have been poisoned.
  % %
  % The first is an \emph{alternative contrastive explanation} as the program has not been changed (that is, $\pr = \pf$), the other two are \emph{hypothetical contrastive explanations}
  % %
\end{example}


\paragraph{Visualization of Contrastive Explanations}
\begin{itemize}
  \item This visualization show the comparison of all involved graphs.
  \item As before, the reference model subgraph $\mgpi{\pr}{\m_r}$ is coloured in purple whereas the foil model subgraph $\mgpi{\pf}{\m_f}$ is coloured in green.
  \item Nodes and eges that are not in $\mgpi{\pf}{\m_f}$, are shown with less opacity.
  \item Rule nodes that can be removed (i.e., that are in $\removable$) are shown with a dashed border.
  \item Removed rules are shown with a red border, whereas added rules are shown with a blue border.
  \item Finally, for those constraint rule nudes, that are existentially statisfied by $\m_r$ and $\m_f$ together, have a red background.
  % \comment{This case it's maybe not the best example as our interity constraints here only give us that w and h cannot be together}
\end{itemize}
%

%
\paragraph{Small Discussion on types of queries}
\begin{itemize}
  %
  \item The type of query is implicitly given by the satisfaction relation between $Q$ and $\m_r$.
  \begin{itemize}
    %
    \item If $\m_r \models Q$, then $Q$ is a \emph{Why query}. It does not require contrastive for being answered but our framework support this as a contrast as well (as mentioned earlier).
    %
    \item If $\m_r \nvDash Q$, then $Q$ is a \emph{Why not query}, asking for contrastive explanation of $Q$ starting from $\pr$ and $\m_r$ (and some sets $\addable$ and $\removable$).
  \end{itemize}
  %
  We do not answer in different ways depending on a taxonomy over a query. Queries are always sets of literals, and are answered always in the same way.
\end{itemize}
%


\subsubsection{Selecting the Best Contrastive explanations}
\label{sec:best-contrastive}

\paragraph{Motivation}
\begin{itemize}
  \item In practice, we can still use the $\foilcost$ plus $\mathit{BestFoils}$ approach to select among the best foil to make a contrast with.
  %
  \item However, since those notions are designed without a starting \emph{reference} model in mind, we cannot make interesting differences (semantic based) among the reference and foil models alone.
  %
  \item For instance, in Example~\ref{ex:example4}, we cannot notice any difference between contrastive explanations (2) and (3) by using the $\pdiff$ foil cost function alone, since they are equivalent in terms of removed rules.
  %
  \item However, explanation (2) requires less changes, as in explanation (3) we moreover had to pick $w$ instead of $h$.
  %
  \item In the following, we define an extension of the previous definitions~\ref{def:foil-cost} and~\ref{def:best-foils}, for defining preference that include a \emph{reference} model $\m_R$.
\end{itemize}


\begin{definition}[Contrast cost function]\label{def:contrast-cost}
  Given
  \begin{itemize}
    \item a query $Q$,
    %
    \item a reference program-model pair $(\pr, \m_r)$,
    %
    \item a set of removable labelled rules $\removable \subseteq \pr$,
    %
    \item and a set of addable labelled rules $\addable$,
  \end{itemize}
  %
  a \emph{contrast cost function} for $((\pr, \m_r), \addable, \removable, Q)$ is a function
  %
  \[
    \contrastcost_{(\pr, \m_r),\addable,\removable,Q} :
    \foils(\pr, \addable, \removable, Q) \rightarrow \mathbb{N}.
  \]
  that maps each foil $(\pf, \m_f)$ to a numerical value representing its cost with respect to the reference program-model pair $(\pr, \m_r)$.
\end{definition}

\begin{definition}[Best constrast]\label{def:best-contrasts}
  Given
  \begin{itemize}
    \item a query $Q$,
    %
    \item a reference program $(\pr, \m_r)$,
    %
    \item a set of removable labelled rules $\removable \subseteq \pr$,
    %
    \item and a set of addable labelled rules $\addable$,
    %
    \item and a contrast cost function $\contrastcost_{(\pr, \m_r),\addable,\removable,Q}$,
  \end{itemize}
  %
  the set of \emph{best contrasts} is defined as
  %
  \[
  \bestcontrasts((\pr, \m_r), \addable, \removable, Q, \contrastcost)
    = \operatorname*{arg\,min}_{(\pf, \m_f) \in \foils(\pr, \addable, \removable, Q)}
      \contrastcost_{(\pr, \m_r),\addable,\removable,Q}(\pf, \m_f).
  \]
\end{definition}

\begin{example}[Model-difference cost function]\label{ex:model-difference-cost-function}

  Given
  \begin{itemize}
    \item a query $Q$,
    %
    \item a reference program $\pr$,
    %
    \item a set of removable labelled rules $\removable \subseteq \pr$,
    %
    \item a set of addable labelled rules $\addable$,
    %
    \item and a reference model $\m_r \in AS(\pr)$,
  \end{itemize}
  we define the \emph{model-difference} contrast cost function as
  \[
   \mdiff_{(\pr, \m_r),\addable,\removable,Q}(\pf, \m_f)
      = |\,\m_r \,\triangle\, \m_f\,|,
  \]
  where $\triangle$ denotes the symmetric difference between the models $\m_r$ and $\m_f$.

\end{example}

\begin{example}[Reference–Foil difference cost function]\label{ex:reference-foil-difference-cost-function}
  Extending the previous idea, we define the \emph{reference-foil difference}, contrast cost function as
  \[
    \rdiff_{(\pr, \m_r),\addable,\removable,Q}(\pf, \m_f)
      =\mdiff_{(\pr, \m_r),\addable,\removable,Q}(\pf, \m_f)
      + \pdiff_{\pr,\addable,\removable,Q}(\pf, \m_f).
  \]
\end{example}

\paragraph{Discussion}
\begin{itemize}
  \item The setup for finding the best contrastive explanations is the same as for selecting the best foil.
  \item $\mdiff$ is a \emph{semantic difference} measuring how many atoms differ between the reference and foil models.
  \item $\rdiff$ integrates both syntactic and semantic differences, penalizing foils that diverge from the reference either in their rules or in their resulting models.
  \item Note, now that we can have alternative and hypothetical explanations.
  \item We can consider different priorities among those cost functions.
  In our case, \rdiff\ gives equal importance to both syntactic and semantic differences, but we could also define a weighted sum to prioritize one over the other.
  \comment{TODO BRAIS: Include phrase to moticate that model difference might make more sense for end user vs program difference for debugging.}
\end{itemize}

\begin{example}[Selecting the best contrastive explanations]\label{ex:best-contrastive-explanations}
  Following our example, the two contrastive explanations depicted in Figure~\ref{fig:contrastive},
  have the same cost according to the $\pdiff$ function, that is, a weight of $1$ each.
  However, if compared using $\mdiff$, which counts the differences among $\m_r$ and $\m_f$,
  is easy to see that contrast we obtain
  a weight of $6$ for the foil corresponding first explanation removing rule $r7$,
  $4$ for the foil corresponding to second explanation removing rule $r6$.
  %
  Note how when using $\mdiff$ alone, we do not penalize any addition/removal to the reference program.
  %

  %
  Alternatively, we can use $\rdiff$ instead that can be computed as the sum of the weights previously reported for the other two cost functions.
  The ordering among foil induced by this, better matches the intuition of \emph{closeness} between the reference and foil.
  %
  In short, the second explanation would be the preferred explanation since the hypothetical contrastive world is closer to the reference.
  \comment{
    TODO Brais -- my intuition was that for this cost function (1) and (2) would collide
    however, strange effect: when we use this cost function, removing fact $d.$ effectively leads to increasing of $2$ units in the cost, since we remove the rule and the atom as well...
    Nevertheless, this effect can be interesting in other cases, where the atom could be derived by other rule?
  }
  %

  %

\end{example}

\subsubsection{Selecting reason}
\label{sec:contrast-reasons}

\comment{TODO BRAIS: Formalize Select a single reason for each atom}
