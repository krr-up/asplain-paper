
\section{Implementation}

We implemented our approach in a system called \asplain.
\asplain\ builds on the \clingo\ system, leveraging its API and meta-programming features~\citep{karoscwa21a} to construct explanations.
Each component of the formalization is represented as facts in ASP.
The system consists of a collection of \clingo\ encodings that take these facts as input, together with Python scripts that orchestrate the overall explanation generation process.
While selected ASP encodings are presented in this paper, details of the Python integration are omitted for brevity.
In addition, \asplain\ provides a user interface for visualizing program graphs, model subgraphs, and contrast graphs, as well as for generating natural language explanations of these graphs using large language models.
The implementation is publicly available at \url{https://github.com/potassco/asplain}.

An overview of the main system workflow is shown in Figure~\ref{fig:asplain}.
Green nodes correspond to user input, purple nodes to internal \asplain\ ASP encodings, gray nodes to control components, and yellow nodes to internal fact representations.
Dashed blue arrows denote optional inputs.
%
The workflow is divided into four stages.
First, the program graph $\pg{\pr}$ is computed from the input program $\pr$.
Second, the model subgraph $\mgpi{\pr}{\m_r}$ is constructed from $\pg{\pr}$ and an optional reference model $\m_r$.%
\footnote{If no reference model is provided, the system computes all stable models. If no model is found, the system proceeds to abduction.}
Third, abduction is performed to obtain the best foils for a given query $Q$ and cost function $\foilcost$.
Finally, if a foil is found, a contrast graph is constructed, possibly using a model subgraph of the reference program when it is satisfiable.
%
We now describe each of these stages in detail in the following subsections.

\begin{figure}[!h]
    \includegraphics[width=\textwidth]{diagrams/asplain.pdf}
    \caption{Architecture and workflow of \asplain}
    \label{fig:asplain}
\end{figure}


% \subsection{Program Graph Construction}
% \begin{itemize}
%       \item We use the \clingo's meta-programming features to construct the program graphs.
%       \item These features allow us to access a linearized representation of a given ASP program
%             in the form of facts,
%             which includes all grounded rules and atoms.
%       \item For details on the reified representation provided by clingo,
%             we refer the reader to~\cite{karoscwa21a}.
%             \item If the user provides a non-ground program, this program is grounded together with the instance to obtain the reified representation.
%             \footnote{The user must ensure that the grounding is within the accepted scope of the system and does not generate auxiliary atoms.}
%             \item Program graphs and model subgraphs are represented using facts of the form \texttt{node/2} and \texttt{edge/3},
%             where the first argument identifies the graph instance $G \in \{\mathit{reference, } \mathit{foil, } \mathit{contrast, } \mathit{model(reference)} , \mathit{model(foil)} \}$.
%             \item A graph $G=\pgfull$ is represented using the following facts:
%             \begin{itemize}
%                   \item \texttt{node(G, atom(A))} encodes an atom $A$ as a node in $\Va$,
%                   \item \texttt{node(G, rule(choice(H),normal(B)))} encodes a choice rule as a node in $\Vc$,
%                   \item \texttt{node(G, rule(disjunction(H),normal(B)))} encodes a disjunctive rule as a node in $\Vd$,
%                   \item \texttt{edge(G, T, (From, To))} encodes an edge from \texttt{From} to \texttt{To} in $\Epos$ or $\Eneg$, depending on whether $T$ is \texttt{positive} or \texttt{negative}.
%             \end{itemize}
%             \item We keep the same identifiers for rules as in the reified output of clingo,
%             where $H$ and $B$ are numerical identifier for atom and literal tuples in the reified output.
%             This gives unique identifiers for each grounded rule and differentiates disjunctive from choice rules.
%             However, for readability, in the listings presented on this paper, we replace the rule identifiers identifiers by the labels used in the formalization.
%             For instance, instead of \texttt{rule(choice(1),normal(1))} we write \texttt{rule(r1)}.
%             The original files can be found in the system repository.
%             \item The facts representing the program graph from Figure~\ref{fig:program-graph} are shown in Listing~\ref{lst:ex:pg}.
%             %
%             \item The facts for the reference program graph \pg{\pr} are generated using the encoding in Listing~\ref{lst:reify-to-pg} for a given \pr.
%             \item Line \ref{reify:rule} creates nodes in $\Vd$ and $\Vc$ from the rules in the reification,
%             while line \ref{reify:atom} generates nodes for the atoms using an auxiliary predicate \texttt{symbol\_literal}
%             mapping atom names into internal literal numbers which are used in the reification.
%             \item The rule in Lines \ref{reify:edge:start} to \ref{reify:edge:end} creates positive edges from atoms in $\Va$ to rule nodes in $\Vc \cup \Vd$,
%             (the generation of negative edges is done analogously and is omitted for brevity).
%             \item The last two rules create positive edges from disjunctive and choice rule nodes to their head atoms, respectively.
%             \footnote{Notice that rules of form \texttt{rule(H,sum(B))} are currently not supported.}

% \end{itemize}

\subsection{Program Graph Construction}

We use \clingo's meta-programming features to construct program graphs.
These features provide access to a linearized representation of an ASP program in the form of facts,
including all grounded rules and atoms.
If the user provides a non-ground program,
the program is grounded together with the instance to obtain its reified representation.%
\footnote{The user must ensure that grounding stays within the accepted scope of the system and does not introduce auxiliary atoms.}
For details on the reified representation produced by \clingo,
we refer the reader to~\cite{karoscwa21a}.


Program graphs and model subgraphs are represented using facts of the form \texttt{node/2} and \texttt{edge/3},
where the first argument identifies the graph instance
$G \in \{\mathit{reference}, \mathit{foil}, \mathit{contrast}, \mathit{model(reference)}, \mathit{model(foil)}\}$.
%
A graph $G = \pgfull$ is represented using the following predicates.
Nodes are encoded by \texttt{node(G, atom(A))} for atoms in $\Va$,
\texttt{node(G, rule(choice(H),normal(B)))} for choice rules in $\Vc$,
and \texttt{node(G, rule(disjunction(H),normal(B)))} for disjunctive rules in $\Vd$.
Edges are encoded by \texttt{edge(G, T, (From, To))} and belong to $\Epos$ or $\Eneg$,
depending on whether $T$ is \texttt{positive} or \texttt{negative}.

We retain the rule identifiers produced by \clingo's reification.
These identifiers uniquely identify each grounded rule and allow us to distinguish
disjunctive rules from choice rules.
%
The numerical identifiers $H$ and $B$ refer to atom and literal tuples in the reified output.
They are required to reconstruct the rule structure during graph construction,
but become irrelevant once this information is encoded in the graph itself.
%
For readability,
the listings presented in this paper replace reified identifiers with the labels used in the formalization.
For example, instead of \texttt{rule(choice(1),normal(1))},
we write \texttt{rule(r1)}.
The original files using the full reified identifiers are available in the system repository.
%
Listing~\ref{lst:ex:pg} shows the facts representing the program graph from Figure~\ref{fig:program-graph}.

The reference program graph $\pg{\pr}$ is generated using the encoding in Listing~\ref{lst:reify-to-pg}
for a given program $\pr$.
%
Line~\ref{reify:rule} creates nodes in $\Vd$ and $\Vc$ from the reified rules,
while Line~\ref{reify:atom} creates nodes for atoms using the auxiliary predicate \texttt{symbol\_literal},
which maps atom names to the internal literal identifiers used by the reification.
%
The rules in Lines~\ref{reify:edge:start} to~\ref{reify:edge:end} create positive edges
from atoms in $\Va$ to rule nodes in $\Vc \cup \Vd$.
Negative edges are generated analogously and are omitted for brevity.
%
The final two rules create positive edges from disjunctive and choice rule nodes
to their corresponding head atoms.%
\footnote{Rules of the form \texttt{rule(H,sum(B))} are currently not supported.}


\lstinputlisting[caption={Facts representing program graph \pg{P1}}, language=clingos, label={lst:ex:pg}, numbers=left]{encodings/example-pg.lp}

\lstinputlisting[caption={Encoding to generate program graphs (\texttt{reify-to-pg.lp})}, language=clingos, label={lst:reify-to-pg}, numbers=left]{encodings/reify-to-pg.lp}


\subsubsection{Tags for user preferences}
\label{sec:implementation:tags}

We employ the concept of \emph{tags} as a mechanism for attaching additional information
to atoms and rules in a program.
\footnote{Tags are implemented in an external meta-programming toolset for ASP:
\url{https://github.com/potassco/meta-tools}.}
In \asplain, tags serve to identify abducible rules
and to associate natural language descriptions with rules and atoms.
\footnote{This enables the generation of natural language explanations for foils
and improves the user experience when exploring graphs.}
More generally, tags provide a flexible mechanism
for program annotation and explanation customization.

Tags are specified as comments in the encoding that start with \texttt{\% @}.
These comments are internally translated into special theory atoms,
following an approach similar to that used by \xclingo~\citep{cafamu20a}.
Using an ASP encoding, the reification of these theory atoms is translated into facts
that extend the standard reification of the program.
These facts are then linked to nodes in the graph via simple ASP rules in \texttt{reify-to-pg.lp},
thereby extending the program graph representation
with the predicate \texttt{tag/3}.

Listing~\ref{lst:ex:tags} shows an example of tags added to program $\mathit{P1}$
from Listing~\ref{lst:ex:pg}.
The comment in Line~\ref{tags:label} attaches a natural language tag
to the rule in Line~\ref{tags:rule}.
Line~\ref{tags:removable} adds the tag \texttt{removable}
to the fact stating that James drinks the drug.
Tags can also be associated directly with atoms using the \texttt{::} syntax,
as shown in Line~\ref{tags:atom},
where a natural language tag is added to atom \texttt{h}.
The corresponding tag facts extending Listing~\ref{lst:ex:pg}
are shown in Listing~\ref{lst:ex:tags-facs}.

\lstinputlisting[
  caption={Section of example program P1 with tags},
  language=clingos,
  label={lst:ex:tags},
  numbers=left
]{encodings/example-tags.lp}

\lstinputlisting[
  caption={Tag facts extending \pg{P1}},
  language=clingos,
  label={lst:ex:tags-facs},
  numbers=left
]{encodings/example-tags-facs.lp}

The tag system also provides a number of automatically generated tags,
such as the first-order representation of a rule,
its location in the source file,
and the program in which the rule appears.
These built-in tags ensure that all rules are associated with at least one tag.
Since tags are treated as theory atoms,
they additionally prevent unwanted simplification during grounding,
thereby preserving a distinct body for each rule.

Using this infrastructure,
we extract the sets \removable\ and \addable.
These sets are represented using atoms of the form
\texttt{abducible(remove, R)} and \texttt{abducible(add, R)}.
The set \removable\ can be obtained directly from the explicit tag using the rule
\lstinline[language=clingos]{abducible(remove, R) :- tag(reference, R, removable)}.

Rules in \addable\ are not part of the original program.
However, they must be grounded together with the program
in order to correctly identify and link them.
To keep them separate,
such rules are placed under a dedicated program directive
\texttt{\#program addable}.
Then, using the built-in tag that records the program directive,
the set \addable\ is obtained by the rule
\lstinline[language=clingos]{abducible(add, R) :- tag(reference, R, program(addable))}.
%
This information alone is not sufficient to later integrate a rule $R$ into the foil program $\pf$,
as it does not capture the edges incident to $R$.
To address this, we include additional facts for the edges
that must be introduced if $R$ is added.

Some encodings cannot be annotated with tags via comments.
For example, rules originating from an instance may need to be marked as removable
without requiring the user to modify the instance file.
To support this, \asplain\ allows users to provide an additional file
\texttt{dynamic-tags.lp},
in which tags are generated dynamically using ASP rules.
This mechanism offers further flexibility;
for instance, one could add a rule that tags all integrity constraints as removable
to support debugging scenarios.


\subsubsection{Assumption support}

\Asplain\ supports \emph{assumptions} as a mechanism for constraining answer sets.
Assumptions are represented as integrity constraints,
such as the rule \texttt{r7: :- not h.} introduced in program $P2$,
which enforces the presence of atom \texttt{h} in every answer set.
%
Assumptions are integrated into the explanation framework
by including the corresponding constraints in the program
and annotating them with \texttt{@assume(true)} or \texttt{@assume(false)}.
These annotations allow the system to identify the associated rule nodes
in the program graph,
mark them dynamically as removable rules,
and associate them with natural language descriptions.
%
The facts generated for the assumption introduced by rule \texttt{r7}
are shown in Listing~\ref{lst:ex:assumption}.

This functionality enables interactive exploration of answer sets,
allowing users to explicitly include or exclude specific atoms.
It is particularly useful in interactive scenarios,
where users investigate alternative explanations
by varying assumptions about the presence or absence of atoms.


\lstinputlisting[caption={Facts introduced for asssumption represented by rule \texttt{r7}}, language=clingos, label={lst:ex:assumption}, numbers=left]{encodings/example-assumption-pg.lp}


\subsection{Model Subgraph Construction}

A model subgraph $\mgpi{P}{\m}$ is represented using the same facts as the program graph,
but with a different graph identifier of the form \texttt{model(G)}.
%
This allows us to reuse the same predicates while distinguishing program graphs from their corresponding model subgraphs.

To generate a model subgraph,
we adapt the meta-encoding from~\cite{karoscwa21a}
to assign ASP semantics to the program graph facts
and compute stable models as their corresponding model subgraphs.
%
This encoding interprets the graph structure directly as a logic program.

For this purpose, we use the encoding shown in Listing~\ref{lst:model-subgraph}.
A constant \texttt{graph} is used to identify the graph instance to be solved.
%
In the reference case, \texttt{graph} is replaced by \texttt{reference},
while during abduction it is replaced by \texttt{foil}
to compute the model subgraph of the foil program.
%
The rule in Lines~\ref{model:rule:start} to~\ref{model:rule:end} defines when a rule node
$R \in \Vd \cup \Vc$ holds.
%
A rule node holds if all atoms connected by positive edges hold,
and all atoms connected by negative edges do not hold.
%
The two rules in Lines~\ref{model:disjunction:start} to~\ref{model:choice:end}
define when an atom node $A$ holds.
%
An atom holds if it is supported by a satisfied disjunctive or choice rule,
with the expected semantics obtained by mapping the rule head
to a disjunction or a choice, respectively.
%
Finally, the last two rules construct the model subgraph itself
by creating facts for all nodes that hold
and all positive edges between such nodes.
%
Facts representing the model subgraph $\mgpi{P1}{\m_1}$
from Figure~\ref{fig:model-subgraph}
are shown in Listing~\ref{lst:ex:model-subgraph}.

As shown in the second stage of the workflow in Figure~\ref{fig:asplain},
the user may also provide a fixed answer set $\m$
using the predicate \texttt{models/1}.
%
This model is enforced via integrity constraints in the file \texttt{force-model.lp}.


\lstinputlisting[caption={Encoding to generate model subgraphs (\texttt{model-subgraph.lp})}, language=clingos, label={lst:model-subgraph}, numbers=left]{encodings/model-subgraph.lp}

\lstinputlisting[caption={Facts representing model subgraph $\mgpi{P1}{\m 1}$}, language=clingos, label={lst:ex:model-subgraph}, numbers=left]{encodings/example-m1.lp}

\subsection{Abduction}

For the abduction process, we provide the fact representation of the reference program $\pr$,
the facts defining the sets \removable\ and \addable,
and query facts of the form \texttt{query(A, exclude)} and \texttt{query(A, include)},
specifying which atoms must be excluded from or included in the foil, respectively.

To compute the set of foils \foils,
we combine the encoding used for model subgraph construction
(Listing~\ref{lst:ex:model-subgraph}) with \texttt{graph = foil}
and the encoding shown in Listing~\ref{lst:construct-foil}.
Together, these encodings define the search space of candidate foil programs
and their corresponding models.
%
The choice rules in Lines~\ref{foil:remove} and~\ref{foil:add}
select which rules are removed from or added to  $\pg\pr$.
Based on these choices,
the rules in Lines~\ref{foil:node} to~\ref{foil:edge}
construct the facts representing $\pg\pf$.
%
The integrity constraints in Lines~\ref{foil:exclude} and~\ref{foil:include}
ensure that the query conditions are satisfied by the resulting model.
Each stable model of this program corresponds to a foil $(\pf, \m_f) \in \foils$,
where the foil program graph $\pg\pf$ is represented by graph facts with identifier \texttt{foil},
and its model subgraph $\mgpi{\pf}{\m_f}$ by facts with identifier \texttt{model(foil)}.

\lstinputlisting[
  caption={Encoding to construct $\pf$ (\texttt{construct-foil.lp})},
  language=clingos,
  label={lst:construct-foil},
  numbers=left
]{encodings/construct-foil.lp}

\subsubsection{Preferences for best foils}

Users may additionally specify preferences to compute the set of best foils \bestfoils\
using \clingo's optimization features.
Preferences are expressed using atoms of the form
\texttt{cost(Name, Value, Level)},
where \texttt{Name} identifies a penalization,
\texttt{Value} specifies its numeric cost,
and \texttt{Level} denotes its priority.

The use of priority levels is not part of the formal definition of the foil cost function,
but exploits a feature of \clingo\ that supports lexicographic optimization.
This allows multiple cost criteria to be combined in a structured way.
\comment{TODO SON: Check if this is formal enough or what to link for it.}

Costs are optimized using the weak constraint shown in Listing~\ref{lst:costs},
which is instantiated for each cost atom provided by the user.
As an example, the program-difference cost function $\pdiff$
is encoded in Listing~\ref{lst:ex:costs}.
The first rule penalizes the removal of rules from the reference program,
while the second rule penalizes the addition of rules,
both with cost~1 at priority level~2.

Additional cost functions can be combined with $\pdiff$.
For example, Listing~\ref{lst:ex:costs} includes a cost that penalizes
the removal of rules that are not assumptions.
This encourages the system to prefer foils
that modify user-provided assumptions before altering other rules.
By assigning this cost a higher priority level~(3) than $\pdiff$~(2),
both criteria can be optimized lexicographically.

Cost functions may also depend on information from
the reference and foil model subgraphs,
allowing preferences to be defined over both programs and models.


\lstinputlisting[caption={Weak constraint for costs (\texttt{cost.lp})},language=clingos, label={lst:costs}, numbers=left]{encodings/cost.lp}

\lstinputlisting[caption={Encoding for program-difference cost function \pdiff }, language=clingos, label={lst:ex:costs}, numbers=left]{encodings/example-program-difference.lp}

\lstinputlisting[caption={Encoding penalizing the removal of rules that are not assumptions}, language=clingos, label={lst:ex:costs}, numbers=left]{encodings/example-cost-assumption.lp}


% \subsection{Contrastive Explanation}

% Given the fact representations of the reference program $\pr$,
% its model subgraph $\mgpi{\pr}{\m_r}$,
% and a foil $(\pf, \m_f)$,
% we construct the contrast graph
% $\cg{\pr}{\m_r}{\pf}{\m_f}$
% using the identifier \texttt{contrast}.
%
The contrast graph is then obtained using a simple ASP encoding
that combines the nodes occurring in both models
and includes the rule nodes corresponding to constraints
that would have fired in either program.

\comment{TODO SUSANA: Add implementation for a single explanation when formalization is ready}
